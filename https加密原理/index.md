# HTTPS加密原理


## 前言
最近在学习网络相关知识，看了《图解HTTP》这本书，里面提到了HTTPS加密的相关知识，尤其是对称秘钥加密，非对称密钥加密，数字证书，数字签名等基础知识，感觉有点混乱，于是我需要整理一下这些内容。

## 为什么需要HTTPS
首先，我们得知道为什么需要HTTPS？原因就是HTTP不安全

那HTTP不安全体现在哪里？
1. HTTP存在以下缺点：
-  通信使用明文，无法保证保密性，内容可能会被**窃听**
-  不验证通信方的身份，无法保证可靠性，有可能遭遇**伪装**
-  无法证明报文的完整性，有可能遭遇**篡改**，
	总结一下：就是HTTP的不安全性，可能会导致**被窃听**，**被伪装**，**被篡改**
2. 什么是HTTPS？
	HTTPS就是身披SSL外壳的HTTP。
	HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL或TLS协议代替而已。
	通常情况，HTTP直接和TCP通信，当使用SSL时，则演变为先和SSL通信，再由SSL和TCP通信。
3. HTTPS怎么保证安全？
	HTTPS=HTTP+SSL/TLS,其实就是采用了加密来保证安全，具体如何加密，先说结论：结合对称加密和非对称加密的优点以及数字证书，数字签名的方式来保证通信的安全（也就是SSL/TLS协议的实现)。
 
接下来就来了解这些基础知识点。
## 对称加密
1. 什么是对称加密？
	简单的说，对称加密就是指加密和解密使用同一个密钥，这种方式就叫做对称加密。
	
	对称加密的优点是：算法公开，计算量小，加密速度快，效率高；
	缺点是：没有密钥就无法解密，因此双方必须保存好密钥

	因此只要保证了密钥的安全，那么整个通信过程就可以说是具有保密性的。
	![对称加密](https://raw.githubusercontent.com/LucasZhanye/MyNotePic/master/NoteImg/202405071725037-20240507-NVZuypM5kc.png)

2. 使用对称加密来作为HTTPS的加密可行吗？
	从对称加密的特点来看，通信双方必须得拥有同样的密钥才行，那问题就来了，双方如何协商使用同一把密钥？

	在互联网的场景下，服务端事先无法知道客户端是谁，也做不到跟每一个客户端提前协商好使用的密钥，因此这个密钥协商，是需要通过通信双方以报文的形式沟通确认的。

	如果通过报文的方式传输密钥，就会存在一种问题，报文可能会被**窃听**,也就是可能会有第三方在通信的过程窃听密钥，然后使用密钥去解密报文，这样一来，整个通信过程其实和裸奔无异，因此只使用对称加密无法保证通信的保密性。

	![image.png](https://raw.githubusercontent.com/LucasZhanye/MyNotePic/master/NoteImg/202405081932395-20240508-uUtR7YifLL.png)

## 非对称加密
1. 什么是非对称加密？
	非对称加密简单的来理解，就是有两把密钥，一把叫公钥，一把叫私钥。
	公钥可以公开，任何人都可以获得，私钥不能让其他人知道，并且**使用公钥加密的密文，只有私钥可以解密；使用私钥加密的密文，只有公钥可以解密**
	> 实质上，使用私钥加密，公钥解密不应该叫做解密，应该算是验签，这种场景一般用来验证身份，因为公钥和私钥对应，私钥只有持有人才有，既然公钥能解，那说明私钥是正确的，那这个身份必然是持有人。

	非对称加密的优点：安全，即使数据被拦截，公钥被获取，没有私钥也就无法破解。
	缺点：加密算法比较复杂，加解密效率较低。
	![非对称加密](https://raw.githubusercontent.com/LucasZhanye/MyNotePic/master/NoteImg/202405071744404-20240507-x1EeisJSaH.png)

2. 使用非对称加密来作为HTTPS的加密可行吗？
	根据非对称加密的机制，我们可能会想到这样：客户端在向服务器请求时，服务器先将公钥传输给客户端，然后客户端使用服务器公钥进行加密，服务端拿到加密数据后使用私钥进行解密，由于私钥只有服务器所有，所以由客户端到服务器这一条通道似乎是可以保证安全性的，但是这里又如何保证公钥安全的传输给客户端，如果第三方在服务器传输公钥给客户端时进行拦截，然后使用自己的公钥（他也可以有自己的公钥和私钥）传输给客户端，然后客户端就会拿到这个假的公钥进行加密，他拿到后使用自己的私钥进行解密，然后可以篡改等操作，再使用服务器的公钥来加密发送给服务器，这样一来，服务器也无法感知，就会拿到假的数据了。

	反过来，服务器向客户端发送数据这一过程也无法得到保障，如果服务器使用私钥加密，然后传输给客户端，那就还是有可能出现第三方窃听，拿到这个加密数据，因为公钥是公开的，任何人都可以获取(包括第三方)，然后使用服务器公钥就可以进行解密了，因此这一条传输通道是不可靠的。

	![image.png](https://raw.githubusercontent.com/LucasZhanye/MyNotePic/master/NoteImg/202405081944134-20240508-zCR0NDiCP2.png)
	综上所述，根本原因就是无法确认这个公钥的真实性。总不能给公钥也加密吧，这样一来不就是俄罗斯套娃，无穷无尽了。

	所以，为了解决这个公钥真实性问题，实在没法子了，这就需要引入一个公认的可信任的第三方，这个就是CA机构(Certificate Authority)，他就像是网络世界里的政府，公安局等，具有极高的可信度，在这里他就是公理，由他所颁发的证书我们就认为是安全可信任的。

## 数字证书
数字证书是由CA机构颁发的，用于证明实体身份的合法性，**它包含了实体的公钥和其他相关信息，并由CA进行签名**。

证书由服务器传输给浏览器，浏览器从证书里拿到公钥，然后再进行加密传输，证书就如同身份证，他证明了公钥的真实性，表明公钥的确是来自这个服务器的。

同样这里对于证书的传输，也是会存在传输过程中如何防止被篡改或掉包等问题，但它肯定是解决了这些问题的（否则怎么会最终使用这种方案），接下来慢慢了解

1. 数字证书生成流程
	1. 首先，证书申请者自己生成一对密钥（非对称加密），然后拿着自己的公钥以及其他信息，比如拥有者身份信息等，向CA申请
	2. CA机构在拿到这些信息后，会选择一种**单向**的哈希算法（比如MD5）对这些信息进行加密，加密后的东西称为**摘要**
		> 使用单向哈希算法就是因为它的特点为单向不可逆，只要有一点变化，相同的算法加密后的数据都是完全不同的，这样就可以防止信息被篡改 
	3. CA生成摘要后，还需要使用自己的私钥对这个摘要进行加密(没错，CA自己的私钥，它的公钥也是公开的)，加密后的数据就是**数字签名**了。
	4. 最后，CA会将申请者的摘要和数字签名整合一起，生成数字证书，从而将数字证书颁发给申请者
	
2. 数字证书验证过程
	1. 浏览器拿到证书后，首先使用CA机构的公钥对数字签名进行验签，如果能正确解密，则证明这个证书确实是来自于CA机构的
	2. 接着，使用证书里指明的哈希算法，对证书里的公钥进行加密运算，得到摘要
	3. 对比证书的摘要与步骤2的摘要，是否一致，从而证明公钥有无被篡改
	```ad-note
	注意:这里的CA机构的公钥必须安全地转交给客户端，使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥
	```

	整个流程如下图（来自《图解HTTP》）：
	![image.png](https://raw.githubusercontent.com/LucasZhanye/MyNotePic/master/NoteImg/202405082017527-20240508-7PkgfJwGGe.png)
	基于以上的措施，还有可能存在中间人能够篡改或掉包数字证书吗？
	答案是不能了，首先掉包证书，当然中间人也可以申请自己的证书，但是证书上的其他信息，基本都会包含服务器域名等信息，浏览器是会将它与自己请求的域名作对比，这样就能知道证书有没有被掉包了；其次篡改，浏览器在解签证书后是会对证书的明文进行摘要计算的，得到的结果与证书的摘要一对比就知道有没有被篡改了。
3. 其他的一些说明
	1. 为啥要先生成摘要，再用CA私钥加密，不可以直接用CA私钥加密吗？
		首先得了解摘要算法，也就是常说的散列函数，哈希函数，比如MD5，SHA-1等（这两个安全度不高，在TLS里已经被禁止使用了，目前TLS推荐的是SHA-2），它们能够将任意长度的数据“压缩”成固定长度，而且独一无二的字符串。
		再结合非对称加密的缺点，就是计算耗时，效率不高，所以先生成摘要（因为长度固定较少），这样运算量就小很多，而且得到的数字签名也较小，方便保管和传输，客户端解密的时候速度也会快得多。
	2. CA的信任链
		实质上，全世界顶级CA就只有那么几家，比如DigiCert、VeriSign、Entrust、Let's Encrypt等，全世界所有CA证书申请都得找他们，他们根本忙不过来，因此他们作为顶级CA，往下分了二级，三级CA，低级CA可以让高级CA签名认证，但最后的顶级CA，也就是Root CA，就只能自己证明自己了，这个就叫“自签名证书”或者“根证书”，这个根证书，必须相信，否则都无法闭环，信任链就走不下去了。
		![image.png](https://raw.githubusercontent.com/LucasZhanye/MyNotePic/master/NoteImg/202405091125053-20240509-wsgjBSrPAh.png)
		有了这个证书体系，操作系统和浏览器都内置了各大CA的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链，一层层地验证，直到找到根证书，就能够确认证书是可信的，从而继续验证证书里的公钥。
	3. 证书体系的弱点
		如果CA失误或者被欺骗，签发了错误的证书，虽然证书是真的，但是它代表的网站却是假的。

		还有一种更危险的情况，CA被黑客攻陷，或者CA有恶意，因为根证书是信任的源头，将会导致整个信任链都不可信了。

		针对第一种，开发出了CRL（证书吊销列表，Certificate revocation list）和OCSP（在线证书状态协议，Online Certificate STatus Protocol）,及时废止有问题的证书。
		对于第二种，因为涉及的证书太多，就只能操作系统或浏览器从根上“下狠手”了，撤销对CA的信任，列入“黑名单”，这样它颁发的所有证书都会被认为是不安全的了。
## HTTPS加密原理
有了上面的知识铺垫后，再来理解HTTPS的加密原理就比较易懂了，实质上HTTPS的核心是SSL/TLS的加密。

有关SSL/TLS运行机制的可以看看大佬的这两篇文章：
- [SSL/TLS协议运行机制的概述 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)
- [图解SSL/TLS协议 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

PS：后面有时间我再通过抓包的方式来学习下[HTTPS握手流程](HTTPS握手流程.md)。

**总结来说，HTTPS就是利用了数字证书来保证服务器的公钥安全的发送给客户端，然后再利用非对称加密来安全的传递对称加密生成的密钥，最后再通过这个密钥来进行数据交互。**
> 因为对称加密效率高，在已经建立了安全可信的通信之后，对称加密的密钥就是安全的，没有第三方能够获取到，因此可以放心的使用。

## 学习资料
1. 《图解HTTP》
2. 极客时间-《透视HTTP协议》
3. [安全背后: 浏览器是如何校验证书的 - CJ Ting's Blog](https://cjting.me/2021/03/02/how-to-validate-tls-certificate/)

