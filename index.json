[{"categories":["微服务"],"content":"开发Web应用，参数验证能够帮我们卡掉一些不合法的请求，校验参数的正确与否，能拦截掉无效请求，从而防止错误请求打到后端服务上。 本文介绍使用微服务框架Kratos如何相对舒服一点的做参数验证。 ","date":"2024-05-15","objectID":"/kratos%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%AE%9E%E8%B7%B5/:0:0","tags":["kratos","微服务"],"title":"Kratos参数验证实践","uri":"/kratos%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%AE%9E%E8%B7%B5/"},{"categories":["微服务"],"content":"以前的方式 刚开始接触kratos时，二话不说，直接简单粗暴，就在service层，每一个接口方法里去做参数验证，比如： func (s *UserService) Login(ctx context.Context, req *v1.LoginReq) (*v1.LoginResp, error) { if req.name != \"\" { return nil, errors.New(\"name 不可为空\") } // .... resp, err := s.uc.Login(ctx, req) if err != nil { s.log.Errorf(\"Login fail: %v\", err) return nil, errors.Unwrap(err) } return resp, nil } 这种方式太费劲了，并且每一个都要写（由于每个接口的参数验证都不完全相同），太不优雅了。 ","date":"2024-05-15","objectID":"/kratos%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%AE%9E%E8%B7%B5/:0:1","tags":["kratos","微服务"],"title":"Kratos参数验证实践","uri":"/kratos%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%AE%9E%E8%B7%B5/"},{"categories":["微服务"],"content":"现在的方式 以前的方式不够优雅，主要有几个问题： 参数验证全部自己写 每一个接口都要写参数验证相关代码 对于这两个问题，有以下解决方法： 在golang的领域，已经有比较成熟的参数校验相关的第三方包 validator 了，可以直接拿来用，这样可以不需要所有参数验证都自己写，能简化很多代码量 每个接口都会需要参数验证的情况，可以利用中间件来处理 再考虑到kratos是使用proto来定义接口以及请求参数的，可以结合第三方工具 protoc-go-inject-tag ，实现在proto中定义参数时，定义好参数的校验规则。 ","date":"2024-05-15","objectID":"/kratos%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%AE%9E%E8%B7%B5/:0:2","tags":["kratos","微服务"],"title":"Kratos参数验证实践","uri":"/kratos%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%AE%9E%E8%B7%B5/"},{"categories":["微服务"],"content":"说干就干 自定义中间件 首先，先在Kratos中自定义一个中间件，用来处理参数验证，在internal/pkg/middleware中新建文件validator.go package middleware import ( \"context\" \"mytest/cloudapis/mytest\" \"net/http\" \"sync\" \"github.com/go-kratos/kratos/v2/errors\" \"github.com/go-kratos/kratos/v2/middleware\" \"github.com/go-playground/validator/v10\" \"github.com/go-playground/locales/zh\" ut \"github.com/go-playground/universal-translator\" zhTrans \"github.com/go-playground/validator/v10/translations/zh\" ) var ( gValidate *validator.Validate trans ut.Translator once sync.Once ) // CustomValidator 自定义验证器的结构体 type CustomValidator struct { Field string Msg string ValidateFn validator.Func } // RegisterCustomValidators 注册自定义验证器 func registerCustomValidators(validate *validator.Validate, trans ut.Translator, customValidators []CustomValidator) error { for _, cv := range customValidators { // 注册翻译器 if cv.Msg != \"\" { if err := validate.RegisterTranslation( cv.Field, // 字段 trans, // 翻译对象 registerTranslator(cv.Field, \"{0}\"+cv.Msg), translate, // 翻译的方法 ); err != nil { } } validate.RegisterValidation(cv.Field, cv.ValidateFn) } return nil } func InitValidator(customValidators ...CustomValidator) { once.Do(func() { // Validate/v10 中文配置 zh := zh.New() uni := ut.New(zh, zh) trans, _ = uni.GetTranslator(\"zh\") // 初始化Validate/V10 gValidate = validator.New() // 注册一个获取json tag的自定义方法 gValidate.RegisterTagNameFunc(func(fld reflect.StructField) string { name := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0] if name == \"-\" { return \"\" } return name }) // 注册默认的翻译器 err := zhTrans.RegisterDefaultTranslations(gValidate, trans) if err != nil { panic(\"Validate/v10 international error: \" + err.Error()) } // 注册自定义验证器 err = registerCustomValidators(gValidate, trans, customValidators) if err != nil { panic(\"Failed to register custom validators: \" + err.Error()) } }) } // registerTranslator 为自定义字段添加国际化功能 func registerTranslator(tag string, msg string) validator.RegisterTranslationsFunc { return func(trans ut.Translator) error { if err := trans.Add(tag, msg, false); err != nil { return err } return nil } } // translate 自定义字段的翻译方法 func translate(trans ut.Translator, fe validator.FieldError) string { msg, err := trans.T(fe.Tag(), fe.Field()) if err != nil { panic(fe.(error).Error()) } return msg } // Validate 参数校验中间件 func Validate() middleware.Middleware { return func(handler middleware.Handler) middleware.Handler { return func(ctx context.Context, req interface{}) (interface{}, error) { // do something entering err := gValidate.Struct(req) if err != nil { errs := err.(validator.ValidationErrors) return nil, errors.New(http.StatusBadRequest, mytest.ErrorReason_ERROR_REASON_PARAMS.String(), errs[0].Translate(trans)) } defer func() { // do something exiting }() return handler(ctx, req) } } } 从上述代码中，我们定义了一个InitValidator，他接收一个CustomValidator类型切片，这个就是自定义校验规则的结构，支持我们自己定义一些特殊的校验规则： type CustomValidator struct { Field string Msg string ValidateFn validator.Func } 我们只需要实现一个ValidateFn,然后将这个struct在初始化时丢进去，就能够支持我们的自定义的校验规则 自定义校验规则 只需要定义一个ValidateFn方法，比如： func ValidateQuarter(f1 validator.FieldLevel) bool { field := f1.Field().String() regexPattern := `^Q[1-4]'[0-9]{2}$` // 使用正则表达式进行匹配 matched, err := regexp.MatchString(regexPattern, field) if err != nil { return false } return matched } 之后再丢进InitValidator: localMiddleware.InitValidator(localMiddleware.CustomValidator{ Field: \"quarter\", Msg: \"季度格式不正确\", ValidateFn: custom.ValidateQuarter, }) 注册中间件 定义好中间件后，在http.go和grpc.go中注册这个中间件: image.png proto中定义规则 在proto文件中可以这样使用，通过@gotags: validate:\"required\"的形式设置参数规则，如下： message QueryOEEInfoReq { // @gotags: validate:\"required\" string name = 1; // @gotags: validate:\"required\" string address = 2; // @gotags: validate:\"quarter\" string id = 3; // @gotags: validate:\"quarter\" string quarter = 4; } 已经添加了自定义校验规则的，定义的字段就与validator包默认的字段一样，直接在proto中使用即可 在proto中使用，有几点需要注意： 如果要嵌套校验，比如一个结构嵌套另一个结构，则需要使用dive标注，比如： message Data { // ID 值 后端生成 string id = 1; // @gotags: validate:\"required\" string type = 2; // @gotags: validate:\"quarter\" string quarter = 3; } message C","date":"2024-05-15","objectID":"/kratos%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%AE%9E%E8%B7%B5/:0:3","tags":["kratos","微服务"],"title":"Kratos参数验证实践","uri":"/kratos%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%AE%9E%E8%B7%B5/"},{"categories":["Obsidian"],"content":"本文记录一下我使用的Obsidian插件，感觉挺不错的，同时也推荐给各位。 本文也会持续更新，只要我了解到新的插件，就会记录进来。 Blue Topaz: 这款主题使用的人数非常多，暂时也没有特别多折腾，拿来即用 Style Settings：样式设置插件，主题插件结合这个样式设置插件，可以做到自定义好多样式，使得Obsidian的页面美观，比如文件夹颜色，背景图片等等 Admonition：警告块操作，支持快捷插入警告块，或者Obsidian原生的callout，比较方便，不需要自己手动输入语法 Auto Link Title:自动补全链接标题，这个插件在我们复制了链接时候会自动拉取链接标题，我们就可以不用自己手动输入标题 Banners：文档题头插件，方便设置文章的头部图片等 Charts： 一个图表插件 Clear Unused Images: 可以一键清除未有使用或未有链接的图片 Codeblock Customizer：代码块自定义插件 Commander： 可以自定义命令 Dataview：十分强大的一款插件，高性能的索引md文件，并能创建复杂的查询视图，比如表格，列表等，可以慢慢摸索功能 Diagrams：一个drawio的画图插件 Editing Toolbar：Markdown语法工具栏，它可以在编辑页面顶部展示MarkDown语法工具栏，方便快速的使用一些不常用的语法 Excalidraw：也是一款画图插件，十分推荐 File Explorer Note Count：展示文件数 Git：自动进行Git操作或备份 Hider：自定义隐藏界面的元素，信息等，这里我用来隐藏阅读视图下的文档属性 Homepage：可以将某个笔记设置为主页 Image auto upload Plugin：自动上传图片到图床，需要配合PicGo或PicList使用 Omnivore: 可以集合Omnivore操作，使得在网页上收藏网址到Omnivore后，在Obsidian可以一键将文章保存下来 QuickAdd：也是一款很好用的插件，可以快速添加命令等 Surfing：可以让Obsidian成为一个浏览器，能够在标签页中浏览任意网址 Templater：模板插件，能够在笔记中使用预定义模板 Tray：可以产生一个托盘，使得关闭Obsidian不会直接退出 Iconize: 可以给文件或文件夹设置图片 Scroll to Top：快速回到顶部或底部的插件 ","date":"2024-05-02","objectID":"/%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E4%BD%BF%E7%94%A8%E7%9A%84obsidian%E6%8F%92%E4%BB%B6/:0:0","tags":["obsidian"],"title":"目前为止使用的Obsidian插件","uri":"/%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E4%BD%BF%E7%94%A8%E7%9A%84obsidian%E6%8F%92%E4%BB%B6/"},{"categories":["Hugo"],"content":"很长一段时间没有整博客，也没时间写博客，最近又重新捣鼓上了，还是觉得得自己搭一个，这次选择的是Hugo这个静态站点生成器，结合Github就能搭建出属于自己的一个博客平台了。 具体Hugo的搭建方式，网上应该有一堆的教程了，我这里就只做一些简单的记录，更细节的还得深入探索才行。（其实还是蛮适合小白的，主要是流程清晰） ","date":"2024-04-26","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["hugo"],"title":"Hugo搭建个人博客","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Hugo"],"content":"1. 安装 直接看官方文档 Windows | Hugo官方文档 安装完成后，可以做个测试确认是否安装成功，一般是获取下版本号： \u003ehugo version hugo v0.124.1-db083b05f16c945fec04f745f0ca8640560cf1ec+extended windows/amd64 BuildDate=2024-03-20T11:40:10Z VendorInfo=gohugoio 看到以上输出信息就表示hugo已经安装成功了。 ","date":"2024-04-26","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:1","tags":["hugo"],"title":"Hugo搭建个人博客","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Hugo"],"content":"2. 创建站点 在终端输入命令：hugo new site Test，就会生成一个Test的目录，里面的子目录就是Hugo创建的，用于站点内容，结构，行为和呈现的,具体每个目录的作用干嘛的，还是直接去看官方文档。 这里要说下的是hugo.toml是整个站点的配置文件，接下来的配置也主要是针对它。 ","date":"2024-04-26","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:2","tags":["hugo"],"title":"Hugo搭建个人博客","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Hugo"],"content":"3. 选择主题 hugo启动站点前，需要先配置好主题（否则你会得到一个Page Not Found页面），这里推荐一款Loveit，网上用的人也挺多，我自己本身使用的也是这个，照例甩上官方文档 主题文档 - 基本概念 - LoveIt 可以从Github上直接下载这个主题的源码，放入themes这个目录，然后在hugo.toml中配置上theme = \"LoveIt\"就可以了。 接下来就可以本地启动站点进行预览了，进入到站点目录中，还是使用终端敲命令： hugo serve -D 然后访问本地的:http://127.0.0.1:1313,就可以看到你的站点了，当然目前的站点空空如也，啥也没有。 你可以创建一篇文章，使用命令:hugo new posts/test.md,这样就会自动在子目录content下创建一个目录posts，并且创建了一个test.md文件，编辑test.md文件，就是你的博客文件。 title: 提示 1. 首先，你要想这个博客能在网页站点上显示出来，你需要将头部的`draft`设置为true，表示非草稿 2. 然后你需要重新启动下命令`hugo server -D`,好像也可以不用，只需要刷新网页就可以 然后你就可以看到如下图： image.png 初始界面如上图，是不是很简陋，那是因为我们还没加上一些主题的配置。 ","date":"2024-04-26","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:3","tags":["hugo"],"title":"Hugo搭建个人博客","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Hugo"],"content":"4.配置 既然选择了主题Loveit，那想要漂亮肯定是要按要求配置的，不懂的怎么配置可以参考这个主题自带的一个example，路径在:themes/LoveIt/exampleSite/config.toml 简单粗暴，可以将这个文件内容直接复制，然后粘贴到站点根目录下的hugo.toml，然后根据显示的页面再去具体调配。 这里放上我用的配置： baseURL = \"https://LucasZhanye.github.io/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"LucasZhang个人博客\" defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 #enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"LucasZhang\" email = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"home\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\u003ci class='fa-solid fa-house'\u003e\u003c/i\u003e\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"主页\" url = \"/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\u003ci class='fa-brands fa-markdown'\u003e\u003c/i\u003e\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 3 identifier = \"tags\" pre = \"\u003ci class='fa-solid fa-tags'\u003e\u003c/i\u003e\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 4 identifier = \"categories\" pre = \"\u003ci class='fa-solid fa-list'\u003e\u003c/i\u003e\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [[menu.main]] weight = 5 identifier = \"github\" pre = \"\u003ci class='fab fa-github fa-fw' aria-hidden='true'\u003e\u003c/i\u003e\" post = \"\" name = \"\" url = \"https://github.com/LucasZhanye\" title = \"GitHub\" # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"light\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 #gitRepo = \"\" # LoveIt 新增 | 0.1.1 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"sha256\" # LoveIt 新增 | 0.2.0 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"LucasZhang个人博客\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \"\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"首页中间的图片\"] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"normal\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"normal\" # LoveIt 新增 | 0.2.0 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"/images/logo.png\" # 标题名称 name = \"LucasZhang个人博客\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # LoveIt 新增 | 0.2.5 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # LoveIt 新增 | 0.2.0 自定义内容 (支持 HTML 格式) custom = '' # LoveIt 新增 | 0.2.0 是否显示 Hugo 和主题信息 hugo = false # LoveIt 新增 | 0.2.0 是否显示版权信息 copyright = true # LoveIt 新增 | 0.2.0 是否显示作者 author = true # 网站创立年份 since = 2022 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = '' # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # LoveIt 新增 | 0.2.0 Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"","date":"2024-04-26","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:4","tags":["hugo"],"title":"Hugo搭建个人博客","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Hugo"],"content":"5. 部署到Github Page 有了前4步，一个静态博客网站其实已经成型了，只不过现在都是在你本地的，别人也没法访问到你的博客网站，这样好像也没啥意义。 因此我们需要借助一个平台来部署我们的博客，这里选择了Github Page，好像Gitee也是可以的，不过没试过，感兴趣可以去试试看哈。 其实最简单粗暴的方法可以很简单： 5.1 创建一个Github仓库 第一步，先到Github中创建一个仓库，仓库名称为XXX.github.io（XXX为你Github账号的用户名，替换即可），权限为public 5.2 上传 第二步，就是进到你站点的根目录，你会发现有一个public目录，这个目录就是你本地运行时生成的（也可以运行hugo命令部署生成），里面就是hugo给你渲染后的静态站点的资源文件这些，进入这个目录，把他上传到刚刚创建的Github仓库中，具体步骤就是： git init git remote add origin 你的Github仓库的路径 git add . git commit -m \"First commit\" git push -u origin master 5.3 完结 完成第二步后，去到Github页面确认文件都已经上传了，然后就可以直接打开浏览器，访问https://xxxx.github.io。就可以看到你的博客站点了。 5.4 以后 以后你想要发布博客，那你就得经历以下几个步骤哈： 本地生成博客文件(xxx.md)，编辑 本地运行看看效果，记得将draft改为true 执行hugo命令进行编译 进入public目录，执行git命令上传: git add . git commit -m \"xxxx\" git push 查看网站 ","date":"2024-04-26","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:5","tags":["hugo"],"title":"Hugo搭建个人博客","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Hugo"],"content":"6. 小结 这一篇主要简单说下Hugo搭建过程，可能细节部分不是很到位，但是作为一个简单记录足够了，也不是什么重点内容，仅仅是记录一番。 PS：是不是会觉得这个博客文章的发布流程有些繁琐，确实是这样的，那有没有好的方法简化步骤？答案是有的，下一篇 Hugo与Obsidian搭配食用 继续唠嗑。 ","date":"2024-04-26","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:6","tags":["hugo"],"title":"Hugo搭建个人博客","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Hugo"],"content":"1. 前言 上一篇简单记录了Hugo搭建个人博客，最后总结了发布一篇文章至少需要这几个步骤： 本地生成博客文件(xxx.md)，编辑 本地运行看看效果，记得将draft改为true 执行hugo命令进行编译 进入public目录，执行git命令上传: git add . git commit -m \"xxxx\" git push 查看网站 其中，步骤比较麻烦的就是第4步了，每一次修改或新增文章后，都需要重新部署，上传git，实在是繁琐！ ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:1:0","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"2. 解决思路 针对上述流程的第1,2步是必不可少的，第2步其实可以省略，修改draft也可以放在第1步，也就是说我们要解决的其实是如何自动编译，并且自动上传git进行部署。 我的思路是这样的：创建两个Github仓库，分别存储笔记的源文件以及博客站点的编译产物public目录，使用Github Action工作流，在完成文章要发布时，将文章更新到源文件仓库，然后Github的工作流会自动帮我们构建编译生成Hugo的public目录，并且自动推送到public目录所在的仓库，如此一来，就可以省了编译部署这一繁琐流程了。 ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:2:0","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"2.1 如何自动编译？ 要自动编译，我们可以使用Github Actions在仓库有更新时自动进行编译，这个是最简单实现的 github action可以了解这里 了解 GitHub Actions - GitHub 文档 操作流程如下： 创建两个仓库，一个为私有的，比如MyNote，用来存放笔记源文件，同时也可以作为一个备份，另一个为公开的，仓库名必须为username.github.io ,这里的username指的是你github账号名 在MyNote仓库里根目录新建.github/workflows目录，然后在里面创建一个main.yaml 编辑main.yaml文件，设置Github Action配置，我的是这样的： name: deploy on: push: workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"0.124.1\" extended: true # 这里最好与本机hugo版本一致，例如：hugo-version: \"0.124.1\" # 有时github部署会自动更新hugo版本导致部署失败 # extended来控制是否为扩展版本 - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: LucasZhanye/LucasZhanye.github.io publish_branch: master publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} 1. 这里你需要关心的有两个：`personal_token`和`external_repository`,其他的基本上照搬即可。 2. `external_repository`指的是你要部署的仓库，这里肯定是我们另一个存放hugo的public目录的仓库了 3. 当然这里hugo的版本尽量与你本机的一样 4. `publish_branch`,如果你的是main分支，那就改为main 这里有一个personal_token，需要在自己的仓库里创建一番，具体如下操作： 在个人github账户下，点击Settings -\u003e Developer Settings -\u003e Personal access tokens -\u003e Tokens(classic),然后点击Generate new token image.png 给Token起个名字，选择有效期为No Expiration，勾选repo以及workflow`,并且repo是要全选 image.png title: 注意 注意创建成功后，这个Token先保存起来，只会出现一次的 创建完Token后，回到博客源仓库，给他设置token，点击仓库的Settings-\u003eSecrets and variables -\u003e Actions,在Secrets栏中点击New repository secret,填入Secret Name和Secret 这里填入的SecretName随便指定，但是这里设置了什么，上面的main.yaml的personal_token的值就是对应的名字。 将第四步创建的Token填入这里的Secret栏处 ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:2:1","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"2.2 实操步骤 完成上述配置后，将源文件仓库代码push到Github上，就会自动执行我们设置好的workflow，然后构建好Hugo站点，这时打开网页访问:xxxx.github.io就可以看到我们的博客站点了。 ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:2:2","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"3. 寻找合适的编辑器 到了这里，Hugo的博客站点已然完成，其实已经可以结束了，但是既然涉及到写作，那选择一款好用的Markdown编辑器肯定会用着很舒服，基于此原因，又去调研了一下当前比较火的笔记软件，最终发现了Obsidian这一款宝藏软件，感觉与他相见恨晚… 之所以选择了Obsidian，很大一个原因是因为他支持本地存储，结合之前搭建Hugo中创建的源文件仓库，就很适合将笔记或博客备份到Github了。 另一个原因是因为他的插件很丰富，真的可以做到很实用并且颜值高~,当然还有其他的许多好玩的，以后慢慢摸索。 既然选择好了编辑器Obsidian，那接下来就是让Hugo与Obsidian搭配起来，让整套流程更加丝滑，做到“all in Obsidian”，也就是我们只需要在Obsidian中编写笔记或博客即可，其他所有事情都不用再操心。 不了解Obsidian的，可以先下载了解使用一番，以下是我个人的一些操作配置。 ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:3:0","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"3.1 Obsidian创建博客文章 Obsidian的插件是非常的丰富的，而且Obsidian是以一个文件夹作为一个仓库的，这一点很完美的适合Hugo的站点，我们可以选择将Hugo的站点目录作为Obsidian的一个仓库，只需要在打开Obsidian之后，选择好这个目录打开就可以（在站点目录下会生成一个.obsidian的目录） 回忆一下，在使用Hugo时，创建文章，我们需要使用命令：hugo new posts/xxx.md，就会帮我们在content目录下的posts文件夹创建一个md文件，并且自动生成了一些文档属性。 这一个步骤是需要使用终端控制台去敲命令的，而到了Obsidian这里，大可不必，插件用用用… 为了实现这一个优化，推荐两个插件:QuickAdd和Templater，还有Commander QuickAdd:是一个可以添加快速命令的插件 Templater：是一个创建模板的插件 Commander: 是一个可以让我们在侧边栏等地方创建自定义的命令按钮 利用这三个，我们可以将创建文章这一个集成到Obsidian里实现，具体如下操作： 首先在站点目录下，创建一个custom目录，再在里面创建两个目录：scripts和templates 在templates目录下创建一个模板文件,比如新建博客模板.md --- title: \"{{VALUE:articleTitle}}\" subtitle: \"\" date: {{VALUE:articleTimestamp}} categories: [{{VALUE:articleCategory}}] tags: [{{VALUE:articleTag}}] toc: enable: true auto: true draft: true --- 这个模板文件定义的是生成的文章的文档属性，里面包含了一些必要的，也可以自行添加。 在scripts下创建脚本文件，比如新建博客脚本.js module.exports = async (params) =\u003e { QuickAdd = params; const title = await QuickAdd.quickAddApi.inputPrompt(\"文章标题 - Title\"); var tags = await QuickAdd.quickAddApi.inputPrompt(\"文章标签 - Tags\"); const categorys = await QuickAdd.quickAddApi.inputPrompt(\"文章类别 - Categories\"); let titleName = title.split(\"/\"); // 将路径字符串拆分成数组 let name = titleName[titleName.length - 1]; // 获取数组的最后一个元素 QuickAdd.variables[\"articleTitle\"] = name; QuickAdd.variables[\"articleFilename\"] = title QuickAdd.variables[\"articleCategory\"] = categorys; QuickAdd.variables[\"articleTag\"] = tags; QuickAdd.variables[\"articleTimestamp\"] = QuickAdd.quickAddApi.date.now('YYYY-MM-DDTHH:mm:ssZ'); }; 这个脚本实质上是用来给模板文件的参数设置值的，这里的title，tag等通过输入提示框来获取，获取到的值会替换掉模板文件中的参数 接下来，在Obsidian中，找到QuickAdd设置页面，点击Manage Macros,输入一个名字，比如\"新建文章\",然后点击add macros image.png image.png 点击Configure,选择脚本，然后点击添加 image.png 之后再点击Template，然后点击配置(小齿轮) image.png image.png 配置如下：这里需要注意的是选择好保存的文件夹后要记得点击Add，否则是不会生效的。这里配置了文件名跟文章Title一样 image.png 然后回到最初的配置页面，新建一个Marco，注意要选择Macro image.png 之后就点亮这个小闪电! image.png 到这里已经创建好了，可以使用ctrl+p调出命令窗口，输入QuickAdd关键字，就可以看到我们新创建的命令了 image.png 点击这个命令，就会出现对话框，让我们输入文件Title等信息，一路输入即可，最终就会创建出来一个文章 最后，我们再利用Commander插件，在侧边栏给我们新增一个命令按钮，同样的操作，打开Commander配置页面，选择要将按钮放在哪个位置，然后添加命令即可。 image.png 比如我的是选择在左侧边栏，那么就会在左侧边栏多一个按钮，点击就是创建文章的流程了，还是十分舒服的 image.png ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:3:1","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"3.2 Obsidian Git操作 上一步已经实现了在Obsidian中去创建博客文章了，这样一来不需要再使用终端去新增，对于“all in Obsidian”更进一步了，仔细想想，目前好像就差一个git push博客文章到源文件仓库这一个操作脱离在Obsidian之外了，那么接下来就来解决掉这个问题。 Obsidian插件是非常的丰富的，其中就有一款是跟Git有关的，叫Obsidian Git,后来又改名为Git，直接在第三方插件库搜索Git即可找到。 因为我们这个仓库本身就是源文件仓库，是存放在Github上的，因此这个目录下有.git目录，Git插件就会识别到，我们只需要配置好Git插件就可以实现自动备份，上传文件了，比如设置每30分钟自动提交push，设置commit message格式等。 同样也可以使用上面提到的插件搞个命令按钮，手动提交，方便我们想要实时发布的情况。 ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:3:2","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"3.3 处理图片问题 通过上面两步，我们已经可以做到了只需要打开Obsidian进行写作即可，其他一概都不用关心，要发布的文章，只需要编辑完成后将文档属性的draft改为true，然后Git会自动备份上传，上传完成后又会自动构建发布。 实现了“all in obsidian”后，我们还有一个问题可以优化处理，那就是图片资源的存放问题，一般有两种处理方法： 与文章放一起，比如创建一个img目录专门存放文章用到的图片，通过相对路径引用，在上传Github时随文章一起上传 使用图床存储，然后通过外链进行引用 其实两种方案都可以，各有各的好处，但是我个人倾向推荐方案2 先说方案1，这里可以使用一个Obsidian的插件：Custom Attachment location 这个插件可以让我们类似Typora一样指定一个目录作为附件存放路径，当我们复制图片进文章时会自动在文章所在路径下指定的目录中保存这个图片，具体路径要自己配置下就可以。 方案2，推荐使用一款工具，叫做 PicList ，需要先下载到本地 PicList是一款高效的云存储和图床平台管理工具，在PicGo的基础上经过深度的二次开发，不仅完整保留了PicGo的所有功能，还增添了许多新的feature。 然后Obsidian中有一个插件Image auto upload Plugin支持这个PicList，通过配置后，可以实现在文章中复制图片时能够自动上传到我们的图床，用起来十分丝滑。 PS: 这里我使用了Github作为图床，穷鬼没法子~ 具体的配置很简单的，可以看看PicList的说明就能上手了，同时打开PicList软件页面也可以对自己的图床进行管理，可以删除图片，增加水印，压缩等等操作 ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:3:3","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"3.4 处理链接问题 当我写完第二篇，在第一篇上将第二篇文章的链接给加上后，在hugo渲染后，页面点击是一个不存在的页面，然后我看了下生成的url路径好像有点不对，然后一搜索发现有牛人已经给了方案去处理hugo渲染链接的问题了，使用了Hugo提供的render hook机制。 参考这篇： 用 hugo render hooks 简化 markdown 中链接、图片的引用 至此，一切就准备就绪了，可以开干了… ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:3:4","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["Hugo"],"content":"4. 小结 这一篇主要是针对Hugo发布博客这一繁琐流程做一个优化，既然选择了Obsidian作为笔记软件，那么日常的文章，笔记自然而然是使用Obsidian来编写记录了，经过摸索，发现了Obsidian的一些插件很适配Hugo发布博客的流程优化，因此将hugo与Obsidian搭配起来一起使用，做到“all in obsidian”，就是只需要使用Obsidian写笔记文章即可，不需要额外再做一系列操作。 ","date":"2024-04-25","objectID":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/:4:0","tags":["hugo","obsidian"],"title":"Hugo与Obsidian搭配食用","uri":"/hugo%E4%B8%8Eobsidian%E6%90%AD%E9%85%8D%E9%A3%9F%E7%94%A8/"},{"categories":["网络"],"content":"前言 最近在学习网络相关知识，看了《图解HTTP》这本书，里面提到了HTTPS加密的相关知识，尤其是对称秘钥加密，非对称密钥加密，数字证书，数字签名等基础知识，感觉有点混乱，于是我需要整理一下这些内容。 ","date":"2024-04-22","objectID":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/:1:0","tags":["network"],"title":"HTTPS加密原理","uri":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"},{"categories":["网络"],"content":"为什么需要HTTPS 首先，我们得知道为什么需要HTTPS？原因就是HTTP不安全 那HTTP不安全体现在哪里？ HTTP存在以下缺点： 通信使用明文，无法保证保密性，内容可能会被窃听 不验证通信方的身份，无法保证可靠性，有可能遭遇伪装 无法证明报文的完整性，有可能遭遇篡改， 总结一下：就是HTTP的不安全性，可能会导致被窃听，被伪装，被篡改 什么是HTTPS？ HTTPS就是身披SSL外壳的HTTP。 HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL或TLS协议代替而已。 通常情况，HTTP直接和TCP通信，当使用SSL时，则演变为先和SSL通信，再由SSL和TCP通信。 HTTPS怎么保证安全？ HTTPS=HTTP+SSL/TLS,其实就是采用了加密来保证安全，具体如何加密，先说结论：结合对称加密和非对称加密的优点以及数字证书，数字签名的方式来保证通信的安全（也就是SSL/TLS协议的实现)。 接下来就来了解这些基础知识点。 ","date":"2024-04-22","objectID":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/:2:0","tags":["network"],"title":"HTTPS加密原理","uri":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"},{"categories":["网络"],"content":"对称加密 什么是对称加密？ 简单的说，对称加密就是指加密和解密使用同一个密钥，这种方式就叫做对称加密。 对称加密的优点是：算法公开，计算量小，加密速度快，效率高； 缺点是：没有密钥就无法解密，因此双方必须保存好密钥 因此只要保证了密钥的安全，那么整个通信过程就可以说是具有保密性的。 对称加密 使用对称加密来作为HTTPS的加密可行吗？ 从对称加密的特点来看，通信双方必须得拥有同样的密钥才行，那问题就来了，双方如何协商使用同一把密钥？ 在互联网的场景下，服务端事先无法知道客户端是谁，也做不到跟每一个客户端提前协商好使用的密钥，因此这个密钥协商，是需要通过通信双方以报文的形式沟通确认的。 如果通过报文的方式传输密钥，就会存在一种问题，报文可能会被窃听,也就是可能会有第三方在通信的过程窃听密钥，然后使用密钥去解密报文，这样一来，整个通信过程其实和裸奔无异，因此只使用对称加密无法保证通信的保密性。 image.png ","date":"2024-04-22","objectID":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/:3:0","tags":["network"],"title":"HTTPS加密原理","uri":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"},{"categories":["网络"],"content":"非对称加密 什么是非对称加密？ 非对称加密简单的来理解，就是有两把密钥，一把叫公钥，一把叫私钥。 公钥可以公开，任何人都可以获得，私钥不能让其他人知道，并且使用公钥加密的密文，只有私钥可以解密；使用私钥加密的密文，只有公钥可以解密 实质上，使用私钥加密，公钥解密不应该叫做解密，应该算是验签，这种场景一般用来验证身份，因为公钥和私钥对应，私钥只有持有人才有，既然公钥能解，那说明私钥是正确的，那这个身份必然是持有人。 非对称加密的优点：安全，即使数据被拦截，公钥被获取，没有私钥也就无法破解。 缺点：加密算法比较复杂，加解密效率较低。 非对称加密 使用非对称加密来作为HTTPS的加密可行吗？ 根据非对称加密的机制，我们可能会想到这样：客户端在向服务器请求时，服务器先将公钥传输给客户端，然后客户端使用服务器公钥进行加密，服务端拿到加密数据后使用私钥进行解密，由于私钥只有服务器所有，所以由客户端到服务器这一条通道似乎是可以保证安全性的，但是这里又如何保证公钥安全的传输给客户端，如果第三方在服务器传输公钥给客户端时进行拦截，然后使用自己的公钥（他也可以有自己的公钥和私钥）传输给客户端，然后客户端就会拿到这个假的公钥进行加密，他拿到后使用自己的私钥进行解密，然后可以篡改等操作，再使用服务器的公钥来加密发送给服务器，这样一来，服务器也无法感知，就会拿到假的数据了。 反过来，服务器向客户端发送数据这一过程也无法得到保障，如果服务器使用私钥加密，然后传输给客户端，那就还是有可能出现第三方窃听，拿到这个加密数据，因为公钥是公开的，任何人都可以获取(包括第三方)，然后使用服务器公钥就可以进行解密了，因此这一条传输通道是不可靠的。 image.png 综上所述，根本原因就是无法确认这个公钥的真实性。总不能给公钥也加密吧，这样一来不就是俄罗斯套娃，无穷无尽了。 所以，为了解决这个公钥真实性问题，实在没法子了，这就需要引入一个公认的可信任的第三方，这个就是CA机构(Certificate Authority)，他就像是网络世界里的政府，公安局等，具有极高的可信度，在这里他就是公理，由他所颁发的证书我们就认为是安全可信任的。 ","date":"2024-04-22","objectID":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/:4:0","tags":["network"],"title":"HTTPS加密原理","uri":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"},{"categories":["网络"],"content":"数字证书 数字证书是由CA机构颁发的，用于证明实体身份的合法性，它包含了实体的公钥和其他相关信息，并由CA进行签名。 证书由服务器传输给浏览器，浏览器从证书里拿到公钥，然后再进行加密传输，证书就如同身份证，他证明了公钥的真实性，表明公钥的确是来自这个服务器的。 同样这里对于证书的传输，也是会存在传输过程中如何防止被篡改或掉包等问题，但它肯定是解决了这些问题的（否则怎么会最终使用这种方案），接下来慢慢了解 数字证书生成流程 首先，证书申请者自己生成一对密钥（非对称加密），然后拿着自己的公钥以及其他信息，比如拥有者身份信息等，向CA申请 CA机构在拿到这些信息后，会选择一种单向的哈希算法（比如MD5）对这些信息进行加密，加密后的东西称为摘要 使用单向哈希算法就是因为它的特点为单向不可逆，只要有一点变化，相同的算法加密后的数据都是完全不同的，这样就可以防止信息被篡改 CA生成摘要后，还需要使用自己的私钥对这个摘要进行加密(没错，CA自己的私钥，它的公钥也是公开的)，加密后的数据就是数字签名了。 最后，CA会将申请者的摘要和数字签名整合一起，生成数字证书，从而将数字证书颁发给申请者 数字证书验证过程 浏览器拿到证书后，首先使用CA机构的公钥对数字签名进行验签，如果能正确解密，则证明这个证书确实是来自于CA机构的 接着，使用证书里指明的哈希算法，对证书里的公钥进行加密运算，得到摘要 对比证书的摘要与步骤2的摘要，是否一致，从而证明公钥有无被篡改 注意:这里的CA机构的公钥必须安全地转交给客户端，使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥 整个流程如下图（来自《图解HTTP》）： image.png 基于以上的措施，还有可能存在中间人能够篡改或掉包数字证书吗？ 答案是不能了，首先掉包证书，当然中间人也可以申请自己的证书，但是证书上的其他信息，基本都会包含服务器域名等信息，浏览器是会将它与自己请求的域名作对比，这样就能知道证书有没有被掉包了；其次篡改，浏览器在解签证书后是会对证书的明文进行摘要计算的，得到的结果与证书的摘要一对比就知道有没有被篡改了。 其他的一些说明 为啥要先生成摘要，再用CA私钥加密，不可以直接用CA私钥加密吗？ 首先得了解摘要算法，也就是常说的散列函数，哈希函数，比如MD5，SHA-1等（这两个安全度不高，在TLS里已经被禁止使用了，目前TLS推荐的是SHA-2），它们能够将任意长度的数据“压缩”成固定长度，而且独一无二的字符串。 再结合非对称加密的缺点，就是计算耗时，效率不高，所以先生成摘要（因为长度固定较少），这样运算量就小很多，而且得到的数字签名也较小，方便保管和传输，客户端解密的时候速度也会快得多。 CA的信任链 实质上，全世界顶级CA就只有那么几家，比如DigiCert、VeriSign、Entrust、Let’s Encrypt等，全世界所有CA证书申请都得找他们，他们根本忙不过来，因此他们作为顶级CA，往下分了二级，三级CA，低级CA可以让高级CA签名认证，但最后的顶级CA，也就是Root CA，就只能自己证明自己了，这个就叫“自签名证书”或者“根证书”，这个根证书，必须相信，否则都无法闭环，信任链就走不下去了。 image.png 有了这个证书体系，操作系统和浏览器都内置了各大CA的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链，一层层地验证，直到找到根证书，就能够确认证书是可信的，从而继续验证证书里的公钥。 证书体系的弱点 如果CA失误或者被欺骗，签发了错误的证书，虽然证书是真的，但是它代表的网站却是假的。 还有一种更危险的情况，CA被黑客攻陷，或者CA有恶意，因为根证书是信任的源头，将会导致整个信任链都不可信了。 针对第一种，开发出了CRL（证书吊销列表，Certificate revocation list）和OCSP（在线证书状态协议，Online Certificate STatus Protocol）,及时废止有问题的证书。 对于第二种，因为涉及的证书太多，就只能操作系统或浏览器从根上“下狠手”了，撤销对CA的信任，列入“黑名单”，这样它颁发的所有证书都会被认为是不安全的了。 ","date":"2024-04-22","objectID":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/:5:0","tags":["network"],"title":"HTTPS加密原理","uri":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"},{"categories":["网络"],"content":"HTTPS加密原理 有了上面的知识铺垫后，再来理解HTTPS的加密原理就比较易懂了，实质上HTTPS的核心是SSL/TLS的加密。 有关SSL/TLS运行机制的可以看看大佬的这两篇文章： SSL/TLS协议运行机制的概述 - 阮一峰的网络日志 图解SSL/TLS协议 - 阮一峰的网络日志 PS：后面有时间我再通过抓包的方式来学习下 HTTPS握手流程 。 总结来说，HTTPS就是利用了数字证书来保证服务器的公钥安全的发送给客户端，然后再利用非对称加密来安全的传递对称加密生成的密钥，最后再通过这个密钥来进行数据交互。 因为对称加密效率高，在已经建立了安全可信的通信之后，对称加密的密钥就是安全的，没有第三方能够获取到，因此可以放心的使用。 ","date":"2024-04-22","objectID":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/:6:0","tags":["network"],"title":"HTTPS加密原理","uri":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"},{"categories":["网络"],"content":"学习资料 《图解HTTP》 极客时间-《透视HTTP协议》 安全背后: 浏览器是如何校验证书的 - CJ Ting’s Blog ","date":"2024-04-22","objectID":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/:7:0","tags":["network"],"title":"HTTPS加密原理","uri":"/https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"}]